<!DOCTYPE html>
<html>
<head>
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
	
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-c.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-csharp.min.js"></script>
  <title>Sam Levinthal | Portfolio</title>
  <meta charset="UTF-8">
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; background: #fafafa; color: #333; }
    img { max-width: 600px; width: 100%; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
  </style>
</head>
<body>
  <h1>Sam Levinthal</h1>
  <h1>Unity & C Projects</h1>

  <h2>Unity Project: Western Dialogue Game</h2>
  <img src="images/websiteSS1.png" alt="Unity Project Screenshot">
  <img src="images/websiteSS2.png" alt="Unity Project Screenshot">
  <p>An exploration and dialog based game for which I coded the full interactive dialog system in C#. The dialogue system includes the following features: interacted NPC turning to face player, locking camera on NPC, free mouse movement during dialog, branching dialog options, and conditional dialog options which are unlocked based upon previous dialog choices.</p>
  <p>Some snippets of code from the Dialogue Engine:</p>
  <pre><code class="language-csharp">

public class DialogueNode { 
    public int id; // node id
    public string speakerName; // name of speaker
    public string dialogueText; // text to be shown
    public DialogueChoice[] choices; // choices to be shown
    public string condition; // conditions for node to be shown
    public string effect; // effects of reaching node
}

[Serializable]
public class DialogueChoice {
    public string choiceText; // text for choice
    public int nextNodeID; // id of node that follows the choice
    public string condition; // conditions of choice
    public string effect; // effects of choice
}

	
public class DialogueTrigger : MonoBehaviour {
    private bool isPlayerInRange = false;
    public DialogueLoader dialogueLoader; // load dialogue


    public void OnEnable() {
        GameObject player = GameObject.FindWithTag("Player");
    }

    void Update() {
        if (Keyboard.current.eKey.wasPressedThisFrame) { // use e key as interact button
            OnInteract(new InputAction.CallbackContext()); 
        }
    }

    public void OnInteract(InputAction.CallbackContext context) {
        if (isPlayerInRange && !DialogueManager.Instance.IsDialogueActive) {
            StartCoroutine(SmoothLookAt(GameObject.FindWithTag("Player").transform, 0.3f)); // npc turns to face player
            dialogueLoader.StartDialogue(this.transform); // start dialogue
        }
    }

    public void OnTriggerEnter(Collider collider) {
        if (collider.gameObject.tag == "Player") { // only allow dialogue to start if player is close enough
            isPlayerInRange = true;
            Debug.Log("Player entered trigger zone");
        }
    }

    public void OnTriggerExit(Collider collider) {
        if (collider.gameObject.tag == "Player") { // only allow dialogue to start if player is close enough
            isPlayerInRange = false;
            Debug.Log("Player left trigger zone");
        }
    }

    private IEnumerator SmoothLookAt(Transform target, float duration) { // hope you like quaternions
        float time = 0f;

        Quaternion startRotation = this.transform.rotation;
        Quaternion targetRotation = startRotation; // set target rotation to initial rotation

        while (time < duration) {
            if (target != null) {
                Vector3 direction = (target.position - this.transform.position); // use player position and npc current position to determine direction
                direction.y = 0f;
                if (direction != Vector3.zero) {
                    targetRotation = Quaternion.LookRotation(direction.normalized); // set target rotation to look rotation
                }
            }

            this.transform.rotation = Quaternion.Slerp(startRotation, targetRotation, time / duration); // determine rotation speed based on time / duration
            time += Time.deltaTime;
            yield return null;
        }

        if (target != null) { // once time >= duration
            Vector3 finalDirection = (target.position - this.transform.position); // determine final look direction
            finalDirection.y = 0f;
            if (finalDirection != Vector3.zero) {
                this.transform.rotation = Quaternion.LookRotation(finalDirection.normalized); // npc finishes rotation
            }
        }
    }
}

  </code></pre>
	
  <h2>C Project: Kernel Shell</h2>
  <p>Some snippets of code from a Kernel Shell made for my class Intro to Computer Systems and Networking:</p>
  <pre><code class="language-c">
  
int main(int argc, char **argv) 
{
    char c;
    char cmdline[MAXLINE];
    int emit_prompt = 1; /* emit prompt (default) */

    /* Redirect stderr to stdout (so that driver will get all output
     * on the pipe connected to stdout) */
    dup2(1, 2);

    /* Parse the command line */
    while ((c = getopt(argc, argv, "hvp")) != EOF) {
        switch (c) {
        case 'h':             /* print help message */
            usage();
	    break;
        case 'v':             /* emit additional diagnostic info */
            verbose = 1;
	    break;
        case 'p':             /* don't print a prompt */
            emit_prompt = 0;  /* handy for automatic testing */
	    break;
	default:
            usage();
	}
    }

	/* Read command line */
	if (emit_prompt) {
	    printf("%s", prompt);
	    fflush(stdout);
	}
	if ((fgets(cmdline, MAXLINE, stdin) == NULL) && ferror(stdin))
	    app_error("fgets error");
	if (feof(stdin)) { /* End of file (ctrl-d) */
	    fflush(stdout);
	    exit(0);
	}

	/* Evaluate the command line */
	eval(cmdline);
	fflush(stdout);
	fflush(stdout);
    } 

    exit(0); /* control never reaches here */
}


void eval(char *cmdline) 
{ 

    char *argv[MAXLINE]; // array of Strings (all command line arguments)
    int bg; // is background job?
    pid_t pid; // store pid of child process

    sigset_t mask; // make a 'sigset_t' to store what signals we want to later block (SIGCHLD)
    sigemptyset(&mask); // create an empty signal set
    sigaddset(&mask, SIGCHLD); // add SIGCHLD to set

    bg = parseline(cmdline, argv); // parse the command line, check if line ends with '&'
    if (argv[0] == NULL) { // if command line is empty
        return;
    }

    // CMDLINE EXECUTION
    if (!builtin_cmd(argv)) { // if not a built in command
        sigprocmask(SIG_BLOCK, &mask, NULL); // block signals in set (SIGCHLD)

        // CHILD PROCESS
        if ((pid = fork()) == 0) { // fork; only child continues through if statement
            setpgid(0,0); // set process group id
            sigprocmask(SIG_UNBLOCK, &mask, NULL); // unblock signals in set (SIGCHLD)
            do_redirect(argv); // redirect file input/output
            if (execve(argv[0], argv, environ) < 0) { // replace current process with argv[0]
                // if execve fails:
                printf("%s: Command not found\n", argv[0]);
                exit(0);
            }
        }

        // PARENT PROCESS
        else if (pid != 0) { 
            addjob(jobs, pid, bg ? BG : FG, cmdline); // create an UNDEF job
            if (!bg) { 
                sigprocmask(SIG_UNBLOCK, &mask, NULL); // unblock signals in set (SIGCHLD)
                waitfg(pid); // wait for FG process to terminate or stop
            }
            else { // case for BG jobs
                printf("[%d] (%d) %s\n", getjobpid(jobs, pid)->jid, pid, cmdline); // print BG job
                sigprocmask(SIG_UNBLOCK, &mask, NULL); // unblock signals in set (SIGCHLD)
            }
        }

    return;
    }
}
				
int parseline(const char *cmdline, char **argv) 
{
    static char array[MAXLINE]; /* holds local copy of command line */
    char *buf = array;          /* ptr that traverses command line */
    char *delim;                /* points to first space delimiter */
    int argc;                   /* number of args */
    int bg;                     /* background job? */

    strcpy(buf, cmdline);
    buf[strlen(buf)-1] = ' ';  /* replace trailing '\n' with space */
    while (*buf && (*buf == ' ')) /* ignore leading spaces */
	buf++;

    /* Build the argv list */
    argc = 0;
    if (*buf == '\'') {
	buf++;
	delim = strchr(buf, '\'');
    }
    else {
	delim = strchr(buf, ' ');
    }

    while (delim) {
	argv[argc++] = buf;
	*delim = '\0';
	buf = delim + 1;
	while (*buf && (*buf == ' ')) /* ignore spaces */
	       buf++;

	if (*buf == '\'') {
	    buf++;
	    delim = strchr(buf, '\'');
	}
	else {
	    delim = strchr(buf, ' ');
	}
    }
    argv[argc] = NULL;
    
    if (argc == 0)  /* ignore blank line */
	return 1;

    /* should the job run in the background? */
    if ((bg = (*argv[argc-1] == '&')) != 0) {
	argv[--argc] = NULL;
    }
    return bg;
}

/* 
 * builtin_cmd - If the user has typed a built-in command then execute
 *    it immediately.  
 */
int builtin_cmd(char **argv) 
{
    if (strcmp(argv[0], "quit") == 0) { // quit command
        exit(0);
    }
    if (strcmp(argv[0], "&") == 0) { 
        return 1;
    }
    if (strcmp(argv[0], "jobs") == 0) { // jobs command
        listjobs(jobs);
        return 1;
    }
    if ((strcmp(argv[0], "fg") == 0) || (strcmp(argv[0], "bg") == 0)) {
        do_bgfg(argv);
        return 1;
    }
    return 0;     /* not a builtin command */
}

void do_redirect(char **argv)
{
        int i;

        for(i=0; argv[i]; i++)
        {
                if (!strcmp(argv[i],"<")) {
                        int inp = open(argv[i + 1], O_RDONLY, 0); // open file for reading
                        dup2(inp, STDIN_FILENO); // duplicate info from file
                        close(inp); // close file
                        /* the line below cuts argv short. This
                           removes the < and whatever follows from argv */
                        argv[i]=NULL;
                }
                else if (!strcmp(argv[i],">")) {
                        int out = open(argv[i + 1], O_WRONLY | O_CREAT | O_TRUNC, 0); // open file for writing
                        dup2(out, STDOUT_FILENO); // duplicate info to file
                        close(out); // close file
                        /* the line below cuts argv short. This
                           removes the > and whatever follows from argv */
                        argv[i]=NULL;
                }
        }
}
</code></pre>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    Prism.highlightAll();
  });
</script>
</body>
</html>
