<!DOCTYPE html>
<html>
<head>
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-c.min.js"></script>
  <title>Sam Levinthal | Portfolio</title>
  <meta charset="UTF-8">
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; background: #fafafa; color: #333; }
    img { max-width: 600px; width: 100%; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
  </style>
</head>
<body>
  <h1>Sam Levinthal</h1>
  <h2>Unity & C Projects</h2>

  <h3>Unity Project: Western Dialog Game</h3>
  <img src="images/websiteSS1.png" alt="Unity Project Screenshot">
  <img src="images/websiteSS2.png" alt="Unity Project Screenshot">
  <p>An exploration and dialog based game for which I coded the full interactive dialog system in C#. The dialog system includes the following features: interacted NPC turning to face player, locking camera on NPC, free mouse movement during dialog, branching dialog options, and unlockable dialog options based on previous dialog choices.</p>

  <h3>C Project: Kernel Shell</h3>
  <p>Some snippets of code from a Kernel Shell made for my class Intro to Computer Systems and Networking</p>
  <pre><code class="language-c">
  
int main(int argc, char **argv) 
{
    char c;
    char cmdline[MAXLINE];
    int emit_prompt = 1; /* emit prompt (default) */

    /* Redirect stderr to stdout (so that driver will get all output
     * on the pipe connected to stdout) */
    dup2(1, 2);

    /* Parse the command line */
    while ((c = getopt(argc, argv, "hvp")) != EOF) {
        switch (c) {
        case 'h':             /* print help message */
            usage();
	    break;
        case 'v':             /* emit additional diagnostic info */
            verbose = 1;
	    break;
        case 'p':             /* don't print a prompt */
            emit_prompt = 0;  /* handy for automatic testing */
	    break;
	default:
            usage();
	}
    }

	/* Read command line */
	if (emit_prompt) {
	    printf("%s", prompt);
	    fflush(stdout);
	}
	if ((fgets(cmdline, MAXLINE, stdin) == NULL) && ferror(stdin))
	    app_error("fgets error");
	if (feof(stdin)) { /* End of file (ctrl-d) */
	    fflush(stdout);
	    exit(0);
	}

	/* Evaluate the command line */
	eval(cmdline);
	fflush(stdout);
	fflush(stdout);
    } 

    exit(0); /* control never reaches here */
}


void eval(char *cmdline) 
{ 

    char *argv[MAXLINE]; // array of Strings (all command line arguments)
    int bg; // is background job?
    pid_t pid; // store pid of child process

    sigset_t mask; // added: make a 'sigset_t' to store what signals we want to later block (SIGCHLD)
    sigemptyset(&mask); // added: create an empty signal set then
    sigaddset(&mask, SIGCHLD); // add SIGCHLD to set

    bg = parseline(cmdline, argv); // parse the command line, check if line ends with '&'
    if (argv[0] == NULL) { // if command line is empty
        return;
    }

    // CMDLINE EXECUTION
    if (!builtin_cmd(argv)) { // if not a built in command
        sigprocmask(SIG_BLOCK, &mask, NULL); // added: block signals in set (SIGCHLD)

        // CHILD PROCESS
        if ((pid = fork()) == 0) { // added: fork; only child continues through if statement
            setpgid(0,0); // added: set process group id
            sigprocmask(SIG_UNBLOCK, &mask, NULL); // added: unblock signals in set (SIGCHLD)
            do_redirect(argv); // added: redirect file input/output
            if (execve(argv[0], argv, environ) < 0) { // replace current process with argv[0]
                // if execve fails:
                printf("%s: Command not found\n", argv[0]);
                exit(0);
            }
        }

        // PARENT PROCESS
        else if (pid != 0) {  // changed: was an if, now is else if // only for parent
            addjob(jobs, pid, bg ? BG : FG, cmdline); // added: create an UNDEF job // Simon showed me how to make a conditional which yeah we kind of learned in datalab but do you know how much has happened since datalab? Tesla stock has fallen at least 20% since then
            if (!bg) { // removed 8.23's original behavior for this if statement
                sigprocmask(SIG_UNBLOCK, &mask, NULL); // added: unblock signals in set (SIGCHLD)
                waitfg(pid); // added: wait for FG process to terminate or stop
            }
            else { // added: case for BG jobs
                printf("[%d] (%d) %s\n", getjobpid(jobs, pid)->jid, pid, cmdline); // added: print BG job
                sigprocmask(SIG_UNBLOCK, &mask, NULL); // added: unblock signals in set (SIGCHLD)
            }
        }

    return;
    }
}
				
int parseline(const char *cmdline, char **argv) 
{
    static char array[MAXLINE]; /* holds local copy of command line */
    char *buf = array;          /* ptr that traverses command line */
    char *delim;                /* points to first space delimiter */
    int argc;                   /* number of args */
    int bg;                     /* background job? */

    strcpy(buf, cmdline);
    buf[strlen(buf)-1] = ' ';  /* replace trailing '\n' with space */
    while (*buf && (*buf == ' ')) /* ignore leading spaces */
	buf++;

    /* Build the argv list */
    argc = 0;
    if (*buf == '\'') {
	buf++;
	delim = strchr(buf, '\'');
    }
    else {
	delim = strchr(buf, ' ');
    }

    while (delim) {
	argv[argc++] = buf;
	*delim = '\0';
	buf = delim + 1;
	while (*buf && (*buf == ' ')) /* ignore spaces */
	       buf++;

	if (*buf == '\'') {
	    buf++;
	    delim = strchr(buf, '\'');
	}
	else {
	    delim = strchr(buf, ' ');
	}
    }
    argv[argc] = NULL;
    
    if (argc == 0)  /* ignore blank line */
	return 1;

    /* should the job run in the background? */
    if ((bg = (*argv[argc-1] == '&')) != 0) {
	argv[--argc] = NULL;
    }
    return bg;
}

/* 
 * builtin_cmd - If the user has typed a built-in command then execute
 *    it immediately.  
 */
int builtin_cmd(char **argv) 
{
    if (strcmp(argv[0], "quit") == 0) { // from class
        exit(0);
    }
    if (strcmp(argv[0], "&") == 0) { // from csapp3e-ch08
        return 1;
    }
    if (strcmp(argv[0], "jobs") == 0) { // from brain
        listjobs(jobs);
        return 1;
    }
    if ((strcmp(argv[0], "fg") == 0) || (strcmp(argv[0], "bg") == 0)) { // also brain
        do_bgfg(argv);
        return 1;
    }
    return 0;     /* not a builtin command */
}

void do_redirect(char **argv)
{
        int i;

        for(i=0; argv[i]; i++)
        {
                if (!strcmp(argv[i],"<")) {
                        /* add code for input redirection below */
                        int inp = open(argv[i + 1], O_RDONLY, 0); // open file for reading
                        dup2(inp, STDIN_FILENO); // duplicate info from file
                        close(inp); // close file
                        /* the line below cuts argv short. This
                           removes the < and whatever follows from argv */
                        argv[i]=NULL;
                }
                else if (!strcmp(argv[i],">")) {
                        /* add code for output redirection here */
                        int out = open(argv[i + 1], O_WRONLY | O_CREAT | O_TRUNC, 0); // open file for writing
                        dup2(out, STDOUT_FILENO); // duplicate info to file
                        close(out); // close file
                        /* the line below cuts argv short. This
                           removes the > and whatever follows from argv */
                        argv[i]=NULL;
                }
        }
}
</code></pre>
</body>
</html>
